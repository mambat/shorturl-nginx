-- TwemProxy支持EVAL命令，但只是将script作为key进行哈希映射到后端redis server

-- "database scheme"
-- database 0: id ~> url
-- database 1: md5 ~> id (lookup if we have shorten the url already)
-- database 2: key "shorten.count" storing the number of shortened urls;
--             the id is generated by (this number + 1) converted to base 62
-- database 3: id ~> hits
-- database 4: id ~> [{referer|user_agent}]
-- database 5: id ~> misses
-- database 6: id ~> [{referer|user_agent}] (when id is not found)

local _M = {
    _VERSION = '0.2'
}
 
local connect = function()
    local redis = require "resty.redis"
    local red = redis:new()
    red:set_timeout(1000) -- 1 sec
    local ok, err = red:connect("127.0.0.1", 6379)
    if not ok then
        ngx.say(err)
        return ngx.exit(ngx.ERROR)
    end
 
    return red
end

local pack_script =  "local short_pre = ARGV[1] "
                  .. "local arg_url = ARGV[2] "
                  .. "local md5_url = ARGV[3] "
                  .. "local id = ARGV[4] "
                  .. "local checkAlready = ARGV[5] "
                  .. "\n "
                  .. "local basen = function(n) "
                  .. "    local digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' "
                  .. "    local t = {} "
                  .. "    repeat "
                  .. "        local d = (n % 62) + 1 "
                  .. "        n = math.floor(n / 62) "
                  .. "        table.insert(t, 1, digits:sub(d, d)) "
                  .. "    until n == 0 "
                  .. "    return table.concat(t, '') "
                  .. "end "
                  .. "\n "
                  .. "if checkAlready or true then " 
                  .. "    redis.call('select', 1) "
                  .. "    local already, err = redis.call('get', md5_url) "
                  .. "    if already then "
                  .. "        return short_pre .. 0 .. already "
                  .. "    end "
                  .. "end "
                  .. "\n "
                  .. "if id then "
                  .. "    redis.call('select', 0) "
                  .. "    local url = redis.call('get', id) "
                  .. "    if url then return 'ERR:RAU' end "
                  .. "else "
                  .. "    redis.call('select', 2) "
                  .. "    local count, err = redis.call('incr', 'shorten.count') "
                  .. "    id = basen(count) "
                  .. "end "
                  .. "\n "
                  .. "if checkAlready or true then "
                  .. "    redis.call('select', 1) "
                  .. "    redis.call('set', md5_url, id) "
                  .. "end "
                  .. "\n "
                  .. "redis.call('select', 0) "
                  .. "redis.call('set', id, arg_url) "
                  .. "\n "
                  .. "return short_pre .. 0 .. id "
 
function exec_pack_script(red, shortPrefix, url, hash, random_alphanum, checkAlready)
    return red:eval(pack_script, 5, "short_pre", "arg_url", "md5_url", "random_alphanum", "checkAlready",
        shortPrefix, url, hash, random_alphanum, checkAlready)
end 

function _M.pack(arg_url, shortPrefix, random, checkAlready)
  
    local unescape_url = ndk.set_var.set_unescape_uri(arg_url)

    local url = unescape_url:gsub("^%s*(.-)%s*$", "%1")

    if url == "" then
      return ngx.exit(400)
    end

    local hash = ngx.md5(url)

    local red = connect()

    if random then

        local random_alphanum = ndk.set_var.set_secure_random_alphanum(12) 

        local res, err = exec_pack_script(red, shortPrefix, url, hash, random_alphanum, checkAlready)
        
        -- comment "--" was illegal in redis lua script, WTF!!
        -- ERR: RANDOM ALREADY USED
        if res and res ~= 'ERR:RAU' then
            ngx.say(res)
            return ngx.exit(ngx.OK)
        end
    end

    local res, err = exec_pack_script(red, shortPrefix, url, hash, nil, checkAlready);
    
    if not res then
        ngx.say(err)
        return ngx.exit(ngx.ERROR)
    end

    ngx.say(res)
    return ngx.exit(ngx.OK)
end

local unpack_script = "local id = ARGV[1] "
                   .. "local referer_agent = ARGV[2] "
                   .. "local recordHits = ARGV[3] "
                   .. "local recordReferAndUserAgent = ARGV[4] "
                   .. "\n "
                   .. "redis.call('select', 0) "
                   .. "local url, err = redis.call('get', id) "
                   .. "if not url then "
                   .. "    if recordHits then "
                   .. "        redis.call('select', 5) "
                   .. "        redis.call('incr', id) "
                   .. "    end "
                   .. "    if recordReferAndUserAgent then "
                   .. "        redis.call('select', 6) "
                   .. "        redis.call('rpush', id, referer_agent) "
                   .. "    end "
                   .. "    -- distinguish the error from misses \n "
                   .. "    return nil "
                   .. "end "
                   .. "\n "
                   .. "if recordHits then "
                   .. "    redis.call('select', 3) "
                   .. "    redis.call('incr', id) "
                   .. "end "
                   .. "if recordReferAndUserAgent then "
                   .. "    redis.call('select', 4) "
                   .. "    redis.call('rpush', id, referer_agent) "
                   .. "end "
                   .. "return url "
 
function _M.unpack(notFoundRedirect, recordHits, recordReferAndUserAgent)
    -- remove the prefix "/" and "0"
    local id = string.sub(ngx.var.request_uri, 3)
    
    -- (referer .. "|" .. user_agent) in the unpack script may result in inexplicable errors, WTF!
    local referer = ngx.var.http_referer or ""
    local user_agent = ngx.var.http_user_agent or ""

    local red = connect()
    local res, err = red:eval(unpack_script, 4, "id", "referer_agent", "recordHits", "recordReferAndUserAgent", 
        id, referer .. "|" .. user_agent, recordHits, recordReferAndUserAgent);

    if res == ngx.null then
        if notFoundRedirect then
            return ngx.redirect(notFoundRedirect)
        end
        ngx.exit(ngx.HTTP_NOT_FOUND)
    end

    return ngx.redirect(res)
end
 
return _M
